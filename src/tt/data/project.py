# class TraceSource:
import json
import os
import shutil
from functools import cache
from pathlib import Path
from typing import Any

import numpy

from tt.data.function import Function
from tt.data.jsonable import JsonSerializable
from tt.data.trace import Trace, TracesConfig, TraceState
from tt.data.trace_source import TraceSource, NullTraceSource, CSVFileTraceSource
from tt.data.view import Views


class Project(JsonSerializable):
    """
    Project tracks and records traces from an external source (usually csv file generated by Vivado).
    When external source changes it can record new version; thus keeping all previous versions available.
    """

    def __init__(self, *,
                 projects_dir: Path,
                 name: str,
                 implied_dt: float,
                 latest_traces_version: int,
                 description: str,
                 dt_unit: str):
        self.project_dir = projects_dir / name
        self.project_json_file = self.project_dir / "project.json"

        data_dir = self.project_dir / "data"
        if not data_dir.exists():
            data_dir.mkdir(parents = True, exist_ok = True)

        self.views = Views.from_json_file(data_dir / "views.json")
        self.__name = name
        self.trace_source = NullTraceSource(self)
        self.__implied_dt = implied_dt
        self.__dt_unit = dt_unit
        self.latest_traces_version = latest_traces_version
        self.__description = description

    @cache
    def apply_stat_function(self,
                            function_name: str,
                            trace_name: str,
                            trace_version: int,
                            cache_id: str) -> float:
        match function_name:
            case "min":
                return min(self.traces(version = trace_version, trace_name = trace_name)[0].y(self))
            case "max":
                return max(self.traces(version = trace_version, trace_name = trace_name)[0].y(self))
            case "range":
                ys = self.traces(version = trace_version, trace_name = trace_name)[0].y(self)
                return max(ys) - min(ys)
            case "mean":
                return float(numpy.mean(self.traces(version = trace_version, trace_name = trace_name)[0].y(self)))
            case "stdev":
                return float(numpy.std(self.traces(version = trace_version, trace_name = trace_name)[0].y(self)))
            case _:
                raise RuntimeError(f"Unsupported function name: {function_name}")

    def persist(self) -> None:
        """
        When changes are made to the project properties this function is called to save it (persist) to the disk.
        """
        if not self.project_dir.exists():
            self.project_dir.mkdir(parents = True, exist_ok = True)

        self.project_json_file.write_text(self.to_json())

    @property
    def dt_unit(self) -> str:
        return self.__dt_unit

    @dt_unit.setter
    def dt_unit(self, dt_unit: str) -> None:
        self.__dt_unit = dt_unit
        self.persist()

    @property
    def description(self) -> str:
        return self.__description

    @description.setter
    def description(self, description: str) -> None:
        self.__description = description
        self.persist()

    @property
    def name(self) -> str:
        """ Name of the project. """
        return self.__name

    @name.setter
    def name(self, name: str) -> None:
        if (self.project_dir.parent / name).exists():
            raise RuntimeError(f"Project named '{name}' already exists!")
        else:
            new_project_dir = self.project_dir.parent / name
            os.rename(self.project_dir, new_project_dir)
            self.project_dir = new_project_dir
            self.__name = name
            self.project_json_file = self.project_dir / "project.json"
            self.persist()

    @property
    def implied_dt(self) -> float:
        """
        Trace source might not contain time column. If so this value will be used to form
        time vector starting from time 0.
        """
        return self.__implied_dt

    @implied_dt.setter
    def implied_dt(self, value: float) -> None:
        self.__implied_dt = value
        self.persist()

    def to_dict(self) -> dict[str, Any]:
        return {
            "project_version": 1,
            "name": self.__name,
            "dir": f"{self.project_dir}",
            "implied_dt": self.__implied_dt,
            "dt_unit": self.dt_unit,
            "latest_traces_version": self.latest_traces_version,
            "trace_source": self.trace_source.to_dict(),
            "description": self.__description
        }

    def set_trace_source_from_csv_file(self, file: Path) -> None:
        if self.trace_source.is_null_trace_source() or self.latest_traces_version == 0:
            self.trace_source = CSVFileTraceSource(file = file, persistence = self)
            self.persist()
        elif self.trace_source != CSVFileTraceSource(file = file, persistence = self):
            raise RuntimeError("Trace source is already set and loaded. You will need to create a new project.")

    def set_trace_source_from_config(self) -> None:
        data = json.loads(self.project_json_file.read_text())
        self.trace_source = TraceSource.from_config(data["trace_source"], self)
        self.persist()

    def load_traces(self) -> tuple[bool, float]:
        """
        Loads traces into project persistent store and updates "latest_traces_version". If traces were
        previously loaded and source did not change, then nothing will be loaded and False returned.
        False is also returned if trace source is NullTraceSource.
        """
        if self.trace_source.is_null_trace_source():
            return False, self.trace_source.change_id()

        elif self.latest_traces_version == 0 or self.trace_source.has_changed():
            df = self.trace_source.load_data()
            prev_data_dir = self.project_dir / "data" / f"{self.latest_traces_version:05}"
            self.latest_traces_version += 1  # advance version
            target_dir = self.project_dir / "data" / f"{self.latest_traces_version:05}"
            target_dir.mkdir(parents = True, exist_ok = True)
            df.write_parquet(file = target_dir / "traces.parquet.lz4", compression = "lz4")
            self.trace_source.update_signature()
            if "TRIGGER" in df.columns:
                res = df.get_column("TRIGGER").to_list()

                def get_tdata():
                    if len(res) > 2:
                        try:
                            float(res[1])
                            return [a[0] for a in enumerate(res[1:]) if a[1] != 0]
                        except ValueError:
                            return [a[0] for a in enumerate(res[2:]) if a[1] != 0]
                    else:
                        return []

                trigger_index = get_tdata()
                t0_index = trigger_index[0] if len(trigger_index) > 0 else 0
                (target_dir / "trigger.json").write_text(json.dumps({"t0_index": t0_index}))
            else:
                (target_dir / "trigger.json").write_text(json.dumps({"t0_index": 0}))
            self.persist()

            # copy notes from prev
            if prev_data_dir.exists():
                shutil.copy(prev_data_dir / "config.json", target_dir / "config.json")

            data_config_file = self.project_dir / "data" / "config.json"
            if not data_config_file.exists():
                data_config_file.write_text(json.dumps({
                    "traces": [{"name": c, "label": c, "state": "Active"} for c in df.columns]
                }, indent = 2))
                versioned_config = {
                    c: {"note": ""} for c in df.columns
                }
                (target_dir / "config.json").write_text(json.dumps(versioned_config, indent = 2))

            return True, self.trace_source.change_id()

        else:
            return False, self.trace_source.change_id()

    def traces(self, version: int, state: TraceState | None = None, trace_name: str | None = None) -> list[Trace]:
        """
        Returns list of Trace(s) for a given version. Version can be negative in which
        case it refers to index from the right simular to indexing in python arrays. This version -1 refers to
        the latest version, version -2 to the previous one and so on. Argument trace_name refers to
        both name and label.
        """
        traces = TracesConfig(
            config_file = self.project_dir / "data" / "config.json",
            latest_traces_version = self.latest_traces_version,
            dt = lambda: self.__implied_dt
        ).get_traces(version)
        traces = traces if state is None else [t for t in traces if t.state == state]
        if trace_name is None:
            return traces
        else:
            return [t for t in traces if t.name == trace_name or t.label == trace_name]

    def add_derivative_trace(self, name: str, function: Function) -> None:
        TracesConfig(
            config_file = self.project_dir / "data" / "config.json",
            latest_traces_version = self.latest_traces_version,
            dt = lambda: self.__implied_dt
        ).add_trace(name, function)

    def update_derivative_trace(self, name: str, function: Function) -> None:
        TracesConfig(
            config_file = self.project_dir / "data" / "config.json",
            latest_traces_version = self.latest_traces_version,
            dt = lambda: self.__implied_dt
        ).update_derivative_trace(name, function)

    def delete_derivative_trace(self, name: str) -> None:
        TracesConfig(
            config_file = self.project_dir / "data" / "config.json",
            latest_traces_version = self.latest_traces_version,
            dt = lambda: self.__implied_dt
        ).delete_derivative_trace(name)


class ProjectManager:
    """
    Class responsible for creating, opening and listing projects.
    """

    def __init__(self, projects_dir: Path):
        """
        :param projects_dir: Directory where projects will be located on the disk. This usually will be ~/.tt/projects/
        """
        self.__projects_dir = projects_dir

    def list_project_names(self) -> list[str]:
        """
        :return: list of all available project names
        """
        return [x.parent.name for x in sorted(self.__projects_dir.glob("**/project.json"))]

    def open_existing_project(self, project_name: str) -> Project:
        """
        :param project_name: name of the project to open
        :return: instance of Project or Exception is raised if no such project exists
        """
        project_json_file = self.__projects_dir / project_name / "project.json"
        if not project_json_file.exists():
            raise RuntimeError(f"Project [{project_name}] does not exist.")
        else:
            data = json.loads(project_json_file.read_text())
            project = Project(
                projects_dir = self.__projects_dir,
                name = data["name"],
                implied_dt = data["implied_dt"],
                latest_traces_version = data["latest_traces_version"],
                description = data["description"],
                dt_unit = data.get("dt_unit", "ms"),
            )
            project.set_trace_source_from_config()
            return project

    def create_new_project(self, project_name: str) -> Project:
        """
        Creates new project. Note that for the project to be usable it needs to be assigned a source by calling
        Project.set_trace_source_from_csv_file(...) or some such function. If project under this name already exist,
        then RuntimeError is raised.
        """
        project_dir = self.__projects_dir / project_name
        if project_dir.exists():
            raise RuntimeError(f"Project [{project_name}] already exists.")

        project = Project(
            projects_dir = self.__projects_dir,
            name = project_name,
            implied_dt = 1,
            latest_traces_version = 0,
            description = "",
            dt_unit = "ms"
        )
        project.persist()
        return project
