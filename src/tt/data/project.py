# class TraceSource:
import json
import os
import shutil
from pathlib import Path
from typing import Any

from src.tt.data.jsonable import JsonSerializable
from src.tt.data.trace import Trace, TracesConfig
from src.tt.data.trace_source import TraceSource, NullTraceSource, CSVFileTraceSource


class Project(JsonSerializable):
    """
    Project tracks and records traces from an external source (usually csv file generated by Vivado).
    When external source changes it can record new version; thus keeping all previous versions available.
    """

    def __init__(self, *, projects_dir: Path, name: str, implied_dt: float, latest_traces_version: int):
        self.project_dir = projects_dir / name
        self.project_json_file = self.project_dir / "project.json"
        self.__name = name
        self.trace_source = NullTraceSource(self)
        self.__implied_dt = implied_dt
        self.latest_traces_version = latest_traces_version

    def exists(self) -> bool:
        """
        :return: True or False indicating if such a project exist on the filesystem.
        """
        return self.project_dir.exists()

    def persist(self) -> None:
        """
        When changes are made to the project properties this function is called to save it (persist) to the disk.
        """
        if not self.project_dir.exists():
            self.project_dir.mkdir()

        self.project_json_file.write_text(self.to_json())

    @property
    def name(self) -> str:
        """ Name of the project. """
        return self.__name

    @name.setter
    def name(self, name: str) -> None:
        if (self.project_dir.parent / name).exists():
            raise RuntimeError(f"Project named '{name}' already exists!")
        else:
            new_project_dir = self.project_dir.parent / name
            os.rename(self.project_dir, new_project_dir)
            self.project_dir = new_project_dir
            self.__name = name
            self.project_json_file = self.project_dir / "project.json"
            self.persist()

    @property
    def implied_dt(self) -> float:
        """
        Trace source might not contain time column. If so this value will be used to form
        time vector starting from time 0.
        """
        return self.__implied_dt

    @implied_dt.setter
    def implied_dt(self, value: float) -> None:
        self.__implied_dt = value
        self.persist()

    def to_dict(self) -> dict[str, Any]:
        return {
            "project_version": 1,
            "name": self.__name,
            "dir": f"{self.project_dir}",
            "implied_dt": self.__implied_dt,
            "latest_traces_version": self.latest_traces_version,
            "trace_source": self.trace_source.to_dict(),
        }

    def set_trace_source_from_csv_file(self, file: Path) -> None:
        if self.trace_source.is_null_trace_source() or self.latest_traces_version == 0:
            self.trace_source = CSVFileTraceSource(file = file, persistence = self)
            self.persist()
        elif self.trace_source != CSVFileTraceSource(file = file, persistence = self):
            raise RuntimeError("Trace source is already set and loaded. You will need to create a new project.")

    def set_trace_source_from_config(self) -> None:
        data = json.loads(self.project_json_file.read_text())
        self.trace_source = TraceSource.from_config(data["trace_source"], self)
        self.persist()

    def load_traces(self) -> bool:
        """
        Loads traces into project persistent store and updates "latest_traces_version". If traces were
        previously loaded and source did not change, then nothing will be loaded and False returned.
        False is also returned if trace source is NullTraceSource.
        """
        if self.trace_source.is_null_trace_source():
            return False

        elif self.latest_traces_version == 0 or self.trace_source.has_changed():
            df = self.trace_source.load_data()
            prev_data_dir = self.project_dir / "data" / f"{self.latest_traces_version:05}"
            self.latest_traces_version += 1  # advance version
            target_dir = self.project_dir / "data" / f"{self.latest_traces_version:05}"
            target_dir.mkdir(parents = True, exist_ok = True)
            df.write_parquet(file = target_dir / "traces.parquet.lz4", compression = "lz4")
            self.trace_source.update_signature()
            self.persist()

            # copy notes from prev
            if prev_data_dir.exists():
                shutil.copy(prev_data_dir / "config.json", target_dir / "config.json")

            data_config_file = self.project_dir / "data" / "config.json"
            if not data_config_file.exists():
                data_config_file.write_text(json.dumps({
                    "traces": [{"name": c, "label": c, "state": "Active"} for c in df.columns]
                }, indent = 2))
                versioned_config = {
                    c: {"note": ""} for c in df.columns
                }
                (target_dir / "config.json").write_text(json.dumps(versioned_config, indent = 2))

            return True

        else:
            return False

    def traces(self, version: int) -> list[Trace]:
        """
        Returns list of Trace(s) for a given version. Version can be negative in which
        case it refers to index from the right simular to indexing in python arrays. This version -1 refers to
        the latest version, version -2 to the previous one and so on.
        """
        return TracesConfig(
            config_file = self.project_dir / "data" / "config.json",
            latest_traces_version = self.latest_traces_version,
            dt = lambda: self.__implied_dt
        ).get_traces(version)


class ProjectManager:
    """
    Class responsible for creating, opening and listing projects.
    """

    def __init__(self, projects_dir: Path):
        """
        :param projects_dir: Directory where projects will be located on the disk. This usually will be ~/.tt/projects/
        """
        self.__projects_dir = projects_dir

    def list_project_names(self) -> list[str]:
        """
        :return: list of all available project names
        """
        return [x.parent.name for x in sorted(self.__projects_dir.glob("**/project.json"))]

    def open_existing_project(self, project_name: str) -> Project:
        """
        :param project_name: name of the project to open
        :return: instance of Project or Exception is raised if no such project exists
        """
        project_json_file = self.__projects_dir / project_name / "project.json"
        if not project_json_file.exists():
            raise RuntimeError(f"Project [{project_name}] does not exist.")
        else:
            data = json.loads(project_json_file.read_text())
            project = Project(
                projects_dir = self.__projects_dir,
                name = data["name"],
                implied_dt = data["implied_dt"],
                latest_traces_version = data["latest_traces_version"]
            )
            project.set_trace_source_from_config()
            return project

    def create_new_project(self, project_name: str) -> Project:
        """
        Creates new project. Note that for the project to be usable it needs to be assigned a source by calling
        Project.set_trace_source_from_csv_file(...) or some such function. If project under this name already exist,
        then RuntimeError is raised.
        """
        project = Project(
            projects_dir = self.__projects_dir,
            name = project_name,
            implied_dt = 1,
            latest_traces_version = 0
        )
        if project.exists():
            raise RuntimeError(f"Project [{project_name}] already exists.")
        else:
            project.persist()
            return project


if __name__ == '__main__':
    pm = ProjectManager(Path.home() / ".tt" / "projects")
    print(pm.list_project_names())

    project: Project = pm.create_new_project("foobar1")
    # project: Project = pm.open_existing_project("pds")
    project.set_trace_source_from_csv_file(Path.home() / "Downloads" / "iladata.csv")
    print(project.load_traces())
    # trs = project.traces(-1)
    # trs[-2].label = "xyz"
    # trs[-1].state = TraceState.INACTIVE
    # project.implied_dt = 1
    # print(trs[-1].xy)
    # project.name = "pds"
